/*
Copyright 2019 The Kubernetes authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package machine

import (
	"context"
	"encoding/json"
	"fmt"

	igntypes "github.com/coreos/ignition/v2/config/v3_2/types"
	"github.com/vincent-petithory/dataurl"
	corev1 "k8s.io/api/core/v1"
	"sigs.k8s.io/controller-runtime/pkg/client"

	mcfgv1 "github.com/openshift/machine-config-operator/pkg/apis/machineconfiguration.openshift.io/v1"
	ctrlcommon "github.com/openshift/machine-config-operator/pkg/controller/common"
	daemonconsts "github.com/openshift/machine-config-operator/pkg/daemon/constants"
)

const (
	kubeconfigKubeletSecret  = "kubeconfig-kubelet-secret"
	machineConfigContentPath = "/etc/mcs-machine-config-content.json"
	machineNamespace         = "openshift-machine-api"
)

// GetConfig fetches the machine config(type - Ignition) from the cluster,
// based on the role/pool request.
func (a *Actuator) GetConfig(role string) ([]byte, error) {
	var ignData []byte

	// Get the machineconfigpool role from the machine label
	mcp := &mcfgv1.MachineConfigPool{}
	key := client.ObjectKey{
		Name: role,
	}
	err := a.client.Get(context.TODO(), key, mcp)
	if err != nil {
		return nil, fmt.Errorf("Cannot get %s machineconfigpool: %w", role, err)
	}

	var currConf string
	if mcp.Status.UpdatedMachineCount > 0 {
		currConf = mcp.Spec.Configuration.Name
	} else {
		currConf = mcp.Status.Configuration.Name
	}

	// Get the rendered machineconfig
	mc := &mcfgv1.MachineConfig{}
	key = client.ObjectKey{
		Name: currConf,
	}
	err = a.client.Get(context.TODO(), key, mc)
	if err != nil {
		return nil, fmt.Errorf("Cannot get the rendered machineconfig: %w", err)
	}

	ignConfig, err := ctrlcommon.ParseAndConvertConfig(mc.Spec.Config.Raw)
	if err != nil {
		return nil, fmt.Errorf("parsing Ignition config failed with error: %w", err)
	}

	// append annotations to mc
	err = appendNodeAnnotations(&ignConfig, currConf)
	if err != nil {
		return nil, fmt.Errorf("cannot append annotation to ignition: %w", err)
	}

	// Append kubeconfig fetch from secret
	err = a.appendKubeconfig(&ignConfig)
	if err != nil {
		return nil, fmt.Errorf("cannot append kubeconfig to ignition: %w", err)
	}

	// Append initial config
	err = appendInitialMachineConfig(&ignConfig, mc)
	if err != nil {
		return nil, fmt.Errorf("cannot append initial machine config file to ignition: %w", err)
	}

	// Append encapsulated ignition file
	err = appendEncapsulated(&ignConfig, mc)
	if err != nil {
		return nil, fmt.Errorf("cannot append encapsulated file to ignition: %w", err)
	}

	if ignData, err = json.Marshal(ignConfig); err != nil {
		return nil, fmt.Errorf("cannot get marshal the updated ignition config: %w", err)
	}

	return ignData, nil
}

// appendKubeconfig fetches an installer-generated secret and appends it to the ignition
func (a *Actuator) appendKubeconfig(conf *igntypes.Config) error {
	// kubeconfigSecret is an asset generated by the
	// openshift installer.
	kubeconfigSecret := &corev1.Secret{}
	key := client.ObjectKey{
		Name:      kubeconfigKubeletSecret,
		Namespace: machineNamespace,
	}
	err := a.client.Get(context.TODO(), key, kubeconfigSecret)
	if err != nil {
		return fmt.Errorf("cannot get %s secret: %w", kubeconfigKubeletSecret, err)
	}
	kubeconfigBytes := kubeconfigSecret.Data["kubeconfig"]
	if len(kubeconfigBytes) == 0 {
		return fmt.Errorf("could not fetch data from the key: 'kubeconfig' in the secret: %s", kubeconfigKubeletSecret)
	}

	// Merge the machineconfig ignition and the kubeconfig secret
	err = appendFileToIgnition(conf, 420, "/etc/kubernetes/kubeconfig", kubeconfigBytes)
	if err != nil {
		return fmt.Errorf("cannot append file to ignition: %w", err)
	}
	return nil
}

func appendNodeAnnotations(conf *igntypes.Config, currConf string) error {
	nodeAnnotations := map[string]string{
		daemonconsts.CurrentMachineConfigAnnotationKey:     currConf,
		daemonconsts.DesiredMachineConfigAnnotationKey:     currConf,
		daemonconsts.MachineConfigDaemonStateAnnotationKey: daemonconsts.MachineConfigDaemonStateDone,
	}
	contents, err := json.Marshal(nodeAnnotations)
	if err != nil {
		return fmt.Errorf("could not marshal node annotations, err: %v", err)
	}
	if err != nil {
		return err
	}
	err = appendFileToIgnition(conf, 420, daemonconsts.InitialNodeAnnotationsFilePath, contents)
	if err != nil {
		return err
	}
	return nil
}

// appendInitialMachineConfig saves the full serialized MachineConfig that was served
// by the MCS when the node first booted.  This currently is only used as a debugging aid
// in cases where there is unexpected "drift" between the initial bootstrap MC/Ignition and the one
// computed by the cluster.
func appendInitialMachineConfig(conf *igntypes.Config, mc *mcfgv1.MachineConfig) error {
	mcJSON, err := json.MarshalIndent(mc, "", "    ")
	if err != nil {
		return err
	}
	appendFileToIgnition(conf, 420, machineConfigContentPath, mcJSON)
	return nil
}

// appendFileToIgnition adds the additional files into the ignition config
func appendFileToIgnition(conf *igntypes.Config, mode int, outPath string, contents []byte) error {
	fileMode := int(mode)
	overwrite := true
	data := dataurl.EncodeBytes(contents)

	file := igntypes.File{
		Node: igntypes.Node{
			Path:      outPath,
			Overwrite: &overwrite,
		},
		FileEmbedded1: igntypes.FileEmbedded1{
			Contents: igntypes.Resource{
				Source: &data,
			},
			Mode: &fileMode,
		},
	}
	if len(conf.Storage.Files) == 0 {
		conf.Storage.Files = make([]igntypes.File, 0)
	}
	conf.Storage.Files = append(conf.Storage.Files, file)
	return nil
}

// appendEncapsulated is used by // machine-config-daemon-firstboot.service to process
// the bits that the main Ignition (that runs in the initramfs) didn't handle such as kernel arguments.
// Unlike in MCS, we need to pass the full ignition here and not an emptied-out version.
func appendEncapsulated(conf *igntypes.Config, mc *mcfgv1.MachineConfig) error {
	tmpcfg := mc.DeepCopy()
	serialized, err := json.Marshal(tmpcfg)
	if err != nil {
		return fmt.Errorf("error marshalling MachineConfig: %v", err)
	}
	err = appendFileToIgnition(conf, 420, daemonconsts.MachineConfigEncapsulatedPath, serialized)
	if err != nil {
		return fmt.Errorf("error appending file to raw Ignition config: %v", err)
	}
	return nil
}
